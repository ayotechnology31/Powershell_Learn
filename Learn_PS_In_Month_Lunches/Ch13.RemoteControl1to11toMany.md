
When we first started to use PowerShell (in version 1), we were playing around with
the Get-Service command and noticed that it had a -computerName parameter.
Hmmm... does that mean it can get services from other computers, too? After a bit
of experimenting, we discovered that’s exactly what it did. We were excited and
started to look for -computerName parameters on other cmdlets. But we were disappointed to find there were only a few. With v2 a few more were added, but the number of commands that have this parameter are vastly outnumbered by the
commands that don’t.
 What we’ve realized since that time is that PowerShell’s creators are a bit lazy—
and that’s a good thing. Because they didn’t want to have to code a -computerName
parameter for every single cmdlet, they created a shell-wide system called remoting.
This system enables you to run any cmdlet on a remote computer. In fact, you can
even run commands that exist on the remote computer but that don’t exist on your
own computer—meaning you don’t always have to install every single administrative cmdlet on your workstation. This remoting system is powerful, and it offers a
number of interesting administrative capabilities.
NOTE Remoting is a huge, complex technology. We’ll introduce you to it
in this chapter and cover usage scenarios that you’ll deal with 80 to 90 percent of the time. But we can’t cover it all, so in the “Further exploration”
section at the end of this chapter, we’ll point you to a must-have resource
that covers remoting’s configuration options.
13.1 The idea behind remote PowerShell
Remote PowerShell works somewhat similarly to Telnet and other age-old remote control technologies. When you run a command, it’s running on the remote computer.
Only the results of that command come back to your computer. But rather than using
Telnet or SSH, PowerShell uses a new communications protocol called Web Services
for Management (WS-MAN).
WS-MAN operates entirely over HTTP or HTTPS, making it easy to route through
firewalls if necessary (because each of those protocols uses a single port to communicate). Microsoft’s implementation of WS-MAN comes in the form of a background service, Windows Remote Management (WinRM). WinRM is installed along with
PowerShell v2 and is started by default on server operating systems like Windows
Server 2008 R2. It’s installed on Windows 7 by default, but the service is disabled. It’s
also included with PowerShell v3, and it’s enabled by default on Windows Server 2012.
 You’ve already learned that Windows PowerShell cmdlets all produce objects as
their output. When you run a remote command, its output objects need to be put into
a form that can be easily transmitted over a network using the HTTP (or HTTPS) protocol. XML, it turns out, is an excellent way to do that, so PowerShell automatically serializes those output objects into XML. The XML is transmitted across the network and is
then deserialized on your computer back into objects that you can work with inside PowerShell. Serialization and deserialization are really just a form of format conversion:
one from objects to XML (serialization), and from XML to objects (deserialization).
 Why should you care how this output is returned? Because those serialized-thendeserialized objects are only snapshots, of sorts; they don’t update themselves continually. For example, if you were to get the objects that represent the processes running on
a remote computer, what you’d get back would only be accurate for the exact point in
time at which those objects were generated. Values like memory usage and CPU utilization won’t be updated to reflect subsequent conditions. In addition, you can’t tell the
deserialized objects to do anything—you can’t instruct one to stop itself, for example.
 Those are basic limitations of remoting, but they don’t stop you from doing some
amazing stuff. In fact, you can tell a remote process to stop itself, but you have to be a
bit clever about it. We’ll show you how later in this chapter.
 To make remoting work, you have two basic requirements:
 Both your computer and the one you want to send commands to must be running Windows PowerShell v2 or v3. Windows XP is the oldest version of Windows on which you can install PowerShell v2, so it’s the oldest version of
Windows that can participate in remoting.
 Ideally, both computers need to be members of the same domain, or of
trusted/trusting domains. It’s possible to get remoting to work outside of a
domain, but it’s tricky, and we won’t be covering it in this chapter. To learn
more about that scenario, open PowerShell and run help about_remote
_troubleshooting.
TRY IT NOW We hope you’ll be able to follow along with some of the examples in this chapter. To participate, you’ll ideally have a second test computer
(or a virtual machine) that’s in the same Active Directory domain as the test
computer you’ve been using up to this point. You can run any version of Windows on that second computer, provided you have PowerShell v2 or v3
installed. If you can’t set up an additional computer or virtual machine, use
“localhost” to create remoting connections to your current computer. You’re
still using remoting, but it isn’t as exciting to be “remote controlling” the
computer at which you’re sitting.
13.2 WinRM overview
Let’s talk a bit about WinRM, because you’re going to have to configure it in order to
use remoting. Once again, you only need to configure WinRM—and PowerShell
remoting—on those computers that will receive incoming commands. In most of the
environments we’ve worked in, the administrators have enabled remoting on every
Windows-based computer (keep in mind that PowerShell and remoting are supported
all the way back to Windows XP). Doing so gives you the ability to remote into client
desktop and laptop computers in the background (meaning the users of those computers won’t know you’re doing so), which can be tremendously useful.
 WinRM isn’t unique to PowerShell. In fact, Microsoft is starting to use it for more
and more administrative communications—even things that use other protocols
today. With that in mind, Microsoft made WinRM able to route traffic to multiple
administrative applications—not only PowerShell. WinRM acts as a dispatcher: when
traffic comes in, WinRM decides which application needs to deal with that traffic. All
WinRM traffic is tagged with the name of a recipient application, and those applications must register as endpoints with WinRM so that WinRM will listen for incoming
traffic on their behalf. This means you’ll not only need to enable WinRM, but you’ll
also need to tell PowerShell to register as an endpoint with WinRM. Figure 13.1 illustrates how the pieces fit together.
 As shown, you can have dozens or even hundreds of WinRM endpoints on your system (PowerShell calls them session configurations). Each endpoint can point to a different application, and you can even have endpoints that point to the same application
but provide different permissions and functionality. For example, you could create a
PowerShell endpoint that only allowed one or two commands, and make it available
to specific users in your environment. We won’t be diving that deep into remoting in
this chapter, but chapter 23 will.

 Figure 13.1 also illustrates the WinRM listener, which in the figure is of the HTTP
variety. A listener sits and waits for incoming network traffic on behalf of WinRM—
kind of like a web server listening for incoming requests. A listener “listens” on a specific port, and on a specific IP address, although the default listener created by
Enable-PSRemoting listens on all local IP addresses.
 The listener connects to the defined endpoint. One way to create an endpoint is to
open a copy of PowerShell—making sure that you’re running it as an Administrator—

Figure 13.1 The relationship
between WinRM, WS-MAN,
endpoints, and PowerShell

and run the Enable-PSRemoting cmdlet. You might sometimes see references to a
different cmdlet, called Set-WSManQuickConfig. You don’t need to run that one;
Enable-PSRemoting will call it for you, and Enable-PSRemoting performs a few extra
steps that are necessary to get remoting up and running. All told, the cmdlet will start
the WinRM service, configure it to start automatically, register PowerShell as an endpoint, and even set up a Windows Firewall exception to permit incoming WinRM traffic.
TRY IT NOW Go ahead and enable remoting on your second computer (or on
the first one, if that’s the only one you have to work with). Make sure you’re
running PowerShell as an administrator (it should say “Administrator” in the
window’s title bar). If you’re not, close the shell, right-click the PowerShell
icon in the Start menu, and select Run as Administrator from the context
menu. If you receive an error message when you enable remoting, stop and
figure it out. You won’t be able to proceed until Enable-PSRemoting runs
without error.
Figure 13.2 shows one of the most common errors you can get when you run
Enable-PSRemoting.
 The error in figure 13.2 typically only occurs on client computers, and the error
message—once you dig into it—tells you exactly what the problem is. We’ve got at least
one network adapter set to “Public.” Remember that Windows Vista and later versions
assign a network type—Work, Home, or Public—to each network adapter. Anything set
to “Public” can’t have Windows Firewall exceptions, so when Enable-PSRemoting tries
to create one, it fails. The only solution is to go into Windows and modify the network
adapter setting so that whatever network you’re on is either “Work” or “Home.” But

Figure 13.2 The most common error you’ll get when you enable remoting on a
client computer

don’t do this if you’re connected to a public network (like a public wireless hotspot),
because you’ll be turning off some valuable security protections.
NOTE You don’t have to worry about this much on server operating systems,
because they don’t have the same restrictions in the OS.
If you’re not excited about having to run around to every computer to enable remoting, don’t worry: you can also do it with a Group Policy object (GPO), too. The necessary GPO settings are built into Windows Server 2008 R2 (and later) domain controllers
(and you can download an ADM template from http://download.Microsoft.com to
add these GPO settings to an older domain’s domain controllers). Open a GPO and
look under Computer Configuration > Administrative Templates > Windows Components. Near the bottom of the list, you’ll find both Remote Shell and Windows Remote
Management. For now, we’ll assume you’ll run Enable-PSRemoting on those computers that you want to configure, because at this point you’re probably only playing
around with a virtual machine or two.

NOTE PowerShell’s about_remote_troubleshooting help topic provides more
coverage on using GPOs. Look for the “How to enable remoting in an enterprise” and “How to enable listeners by using a Group Policy” sections within
that help topic.
WinRM v2 (which is what PowerShell v2 and v3 use) defaults to using TCP port 5985 for
HTTP and 5986 for HTTPS. Those ports help to ensure it won’t conflict with any locally
installed web servers, which tend to listen to 80 and 443 instead. The default remoting
setup created by Enable-PSRemoting only sets up the non-encrypted HTTP listener for
port 5985. You can configure WinRM to use alternative ports, but we don’t recommend
doing so. If you leave those ports alone, all of PowerShell’s remoting commands will
run normally. If you change the ports, you’ll have to always specify an alternative port
when you run a remoting command, which means more typing for you.
 If you absolutely must change the port, you can do so by running this command:
Winrm set winrm/config/listener?Address=*+Transport=HTTP
➥@{Port="1234"}
In this example, “1234” is the port you want to use. Modify the command to use
HTTPS instead of HTTP to set the new HTTPS port.
DON’T TRY IT NOW Although you may want to change the port in your production environment, don’t change it on your test computer. Leave WinRM
using the default configuration so that the remainder of this book’s examples
will work for you without modification.
We should admit that there is a way to configure WinRM on client computers to use
alternative default ports, which means you don’t have to constantly specify an alternative port when you run commands. But for now let’s stick with the defaults Microsoft
came up with. We’ll also note that you can create multiple listeners for WinRM—say,
one for HTTP and one for encrypted HTTPS traffic, or others for different IP
addresses. All of them will deliver traffic to whatever endpoints you’ve configured on
the computer.
NOTE If you do happen to browse around in the Group Policy object settings
for Remote Shell, you’ll notice you can specify how long a remoting session
can sit idle before the server kills it, how many concurrent users can remote
into a server at once, how much memory and how many processes each
remote shell can use, how many remote shells a given user can open at once,
and so on. These are all great ways to help ensure your servers don’t get
overly burdened by forgetful administrators. By default, however, you do have
to be an Administrator to use remoting, so you don’t need to worry about
ordinary users clogging up your servers.

13.3 Using Enter-PSSession and Exit-PSSession
for one-to-one remoting
PowerShell uses remoting in two distinct ways. The first is called one-to-one, or 1:1,
remoting (the second is one-to-many, or 1:n, remoting, and you’ll see it in the next
section). With one-to-one remoting, you’re accessing a shell prompt on a single
remote computer. Any commands you run will run directly on that computer, and
you’ll see results in the shell window. This is vaguely similar to using Remote Desktop
Connection, except that you’re limited to the command-line environment of Windows PowerShell. This kind of remoting also uses a fraction of the resources that
Remote Desktop requires, so it imposes much less overhead on your servers.
 To establish a one-to-one connection with a remote computer, run the following
command:
Enter-PSSession -computerName Server-R2
(You’ll need to provide the correct computer name instead of Server-R2.)
 Assuming you enabled remoting on your remote computer, and you’re all in the
same domain, and your network is functioning correctly, you should get a connection
going. PowerShell lets you know that you’ve succeeded by changing the shell prompt:
[server-r2] PS C:\>
The shell prompt tells you that everything you’re doing is taking place on Server-R2
(or whichever server you connected to). You can run whatever commands you like.
You can even import any modules or add any PSSnapins that happen to reside on that
remote computer.
TRY IT NOW Go ahead and try to create a remoting connection to your second computer or virtual machine. If you haven’t done so, you’ll also need to
enable remoting on that computer before you try to connect to it. Note that
you’re going to need to know the real computer name of the remote computer; WinRM won’t, by default, permit you to connect by using its IP address
or a DNS alias.
Your permissions and privileges carry over across the remote connection. Your copy of
PowerShell will pass along whatever security token it’s running under (it does this with
Kerberos, so it doesn’t pass your username or password across the network). Any command you run on the remote computer will run under your credentials, so you’ll be
able to do anything you’d normally have permission to do. It’s as if you logged into
that computer’s console and used its copy of PowerShell directly.
 Well, almost. Let’s look at a couple of differences:
 Even if you have a PowerShell profile script on the remote computer, it won’t
run when you connect using remoting. We haven’t fully covered profile scripts
yet (they’re in chapter 25), but suffice it to say, they’re a batch of commands
that run automatically each time you open the shell. Folks use them to automatically load shell extensions and modules and so forth. That doesn’t happen
when you remote into a computer, so be aware of that.
 You’re still restricted by the remote computer’s execution policy. Let’s say your
local computer’s policy is set to RemoteSigned, which means you can run local,
unsigned scripts. That’s great, but if the remote computer’s policy is set to the
default, Restricted, it won’t be running any scripts for you when you’re remoting into it.
Aside from those two fairly minor caveats, you should be good to go. But wait—what
do you do when you’re finished running commands on the remote computer? Many
PowerShell cmdlets come in pairs, with one cmdlet doing something and the other
doing the opposite. In this case, if Enter-PSSession gets you into the remote computer, can you guess what would get you out of the remote computer? If you guessed
Exit-PSSession, give yourself a prize. The command doesn’t need any parameters;
run it and your shell prompt will change back to normal, and the remote connection
will close automatically.
TRY IT NOW Go ahead and exit the remoting session, if you created one.
We’re done with it for now.
What if you forget to run Exit-PSSession and instead close the PowerShell window?
Don’t worry. PowerShell and WinRM are smart enough to figure out what you did,
and the remote connection will close all by itself.
 We do have one caution to offer. When you’re remoting into a computer, don’t
run Enter-PSSession from that computer unless you fully understand what you’re
doing. Let’s say you work on Computer A, which runs Windows 7, and you remote into
Server-R2. Then, at the PowerShell prompt, you run this:
[server-r2] PS C:\>enter-pssession server-dc4
This causes Server-R2 to maintain an open connection to Server-DC4, which can start
to create a “remoting chain” that’s hard to keep track of, and which imposes unnecessary overhead on your servers. There may be times when you have to do this—we’re
thinking mainly of instances where a computer like Server-DC4 sits behind a firewall
and you can’t access it directly, so you use Server-R2 as a middleman to hop over to
Server-DC4. But, as a general rule, try to avoid remote chaining.
CAUTION Some people refer to “remote chaining” as “the second hop,” and
it’s a major PowerShell “gotcha.” We offer a hint: If the PowerShell prompt is
displaying a computer name, then you’re done. You can’t issue any more
remote control commands until you exit that session and “come back” to
your computer. Enabling multi-hop remoting is something we’ll discuss in
chapter 23.
When you’re using this one-to-one remoting, you don’t need to worry about objects
being serialized and deserialized. As far as you’re concerned, you’re typing directly on

the remote computer’s console. If you retrieve a process and pipe it to Stop-Process,
it’ll stop running, as you’d expect it to.
13.4 Using Invoke-Command for one-to-many remoting
The next trick—and honestly, this is one of the coolest things in Windows PowerShell—is to send a command to multiple remote computers at the same time. That’s right,
full-scale distributed computing. Each computer will independently execute the command and send the results back to you. It’s all done with the Invoke-Command cmdlet,
and it’s called one-to-many, or 1:n, remoting.
 The command looks something like this:
Invoke-Command -computerName Server-R2,Server-DC4,Server12
➥-command { Get-EventLog Security -newest 200 |
➥Where { $_.EventID -eq 1212 }}
TRY IT NOW Go ahead and run this command. Substitute the name of your
remote computer (or computers) where we put our three server names.
Everything in those outermost curly braces, the {}, will get transmitted to the remote
computers—all three of them. By default, PowerShell will talk to up to 32 computers
at once; if you specified more than that, it will queue them up, and as one computer
completes, the next one in line will begin. If you have an awesome network and powerful computers, you could raise that number by specifying the -throttleLimit
parameter of Invoke-Command—read the command’s help for more information.
Be careful about the punctuation
We need to further consider the syntax for a one-to-many remoting example, because
this is a case where PowerShell’s punctuation can get confusing, and that confusion
can make you do the wrong thing when you start constructing these command lines
on your own.
Here’s the example to consider:
Invoke-Command -computerName Server-R2,Server-DC4,Server12
➥-command { Get-EventLog Security -newest 200 |
➥Where { $_.EventID -eq 1212 }}
There are two commands in this example that use curly braces: Invoke-Command and
Where (which is an alias for Where-Object). Where is entirely nested within the outer
set of braces. The outermost set of braces encloses everything that’s being sent to
the remote computers for execution:
Get-EventLog Security -newest 200 | Where { $_.EventID -eq 1212 }
It can be tough to follow that nesting of commands, particularly in a book like this
one, where the physical width of the page makes it necessary to display the command across several lines of text.
Be sure you can identify the exact command that’s being sent to the remote computer, and that you understand the use for each matched set of curly braces.
We should tell you that you won’t see the -command parameter in the help for
Invoke-Command, but the command we just showed you will work fine. The -command
parameter is an alias, or nickname, for the -scriptblock parameter that you will see
listed in the help. We have an easier time remembering -command, so we tend to use it
instead of -scriptblock, but they both work the same way.
 If you read the help for Invoke-Command carefully (see how we’re continuing to
push those help files?), you’ll also notice a parameter that lets you specify a script file,
rather than a command. That parameter lets you send an entire script from your local
computer to the remote computers—meaning you can automate some complex tasks
and have each computer do its own share of the work.
TRY IT NOW Make sure you can identify the -scriptblock parameter in the
help for Invoke-Command, and that you can spot the parameter that would
enable you to specify a file path and name instead of a script block.
We want to circle back to the -computerName parameter we mentioned at the beginning of the chapter for a bit. When we first used Invoke-Command, we typed a commaseparated list of computer names, as we did in the previous example. But we work with
a lot of computers, and we don’t want to have to type them all in every time. We keep
text files for some of our common computer categories, like web servers and domain
controllers. Each text file contains one computer name per line, and that’s it—no
commas, no quotes, no nothing. PowerShell makes it easy for us to use those files:
Invoke-Command -command { dir }
➥-computerName (Get-Content webservers.txt)
The parentheses here force PowerShell to execute Get-Content first—the same way
parentheses work in math. The results of Get-Command are then stuck into the
-computerName parameter, which works against each of the computers listed in the file.
 We also sometimes want to query computer names from Active Directory, which is
a bit trickier. We can use the Get-ADComputer command (from the ActiveDirectory
module; it’s available in the Windows 7 Remote Server Administration Tools and on
Windows Server 2008 R2 and later domain controllers) to retrieve computers, but we
can’t stick that command in parentheses as we did with Get-Content. Why not?
Because Get-Content produces simple strings of text, which -computerName is expecting. Get-ADComputer, on the other hand, produces entire computer objects, and the
-computerName parameter won’t know what to do with them.
 If we want to use Get-ADComputer, we need to find a way to get only the values from
those computer objects’ Name properties. We’ll show you how in the following example:
Invoke-Command -command { dir } -computerName (
➥Get-ADComputer -filter * -searchBase "ou=Sales,dc=company,dc=pri" |
➥Select-Object -expand Name )
TRY IT NOW If you’re running PowerShell on a Windows Server 2008 R2
domain controller, or on a Windows 7 computer that has the Remote Server
Administration Tools installed, you can run Import-Module ActiveDirectory

and try the preceding command. If your test domain doesn’t have a Sales OU
that contains a computer account, then change ou=Sales to ou=Domain
Controllers, and be sure to change company and pri to the appropriate values for your domain (for example, if your domain is mycompany.org, you’d
substitute mycompany for company and org for pri).
Within the parentheses, we’ve piped the computer objects to Select-Object, and
we’ve used its -expand parameter. We’re telling it to expand the Name property of
whatever came in—in this case, those computer objects. The result of that entire parenthetical expression will be a bunch of computer names, not computer objects—and
computer names are exactly what the -computerName parameter wants to see.
NOTE We hope the previous discussion of the -Expand parameter triggered
some déjà vu: You first saw that parameter in chapter 9. If you need to, flip
back to that chapter for a refresher.
To be thorough, we should mention that the -filter parameter of Get-ADComputer
specifies that all computers should be included in the command’s output. The
-searchBase parameter tells the command to start looking for computers in the specified location—in this case, the Sales OU of the company.pri domain. Again, the
Get-ADComputer command is available only on Windows Server 2008 R2 (and later)
domain controllers, and on Windows 7 (and later) client computers where you’ve
installed the Remote Server Administration Tools (RSAT).
13.5 Differences between remote and local commands
We want to explain a bit about the differences between running commands using
Invoke-Command and running those same commands locally, as well as the differences
between remoting and other forms of remote connectivity. For this discussion, we’ll
use this command as our example:
Invoke-Command -computerName Server-R2,Server-DC4,Server12
➥-command { Get-EventLog Security -newest 200 |
➥Where { $_.EventID -eq 1212 }}
Let’s look at some alternatives and see why they’re different.
13.5.1 Invoke-Command versus -ComputerName
Here’s an alternative way to perform that same basic task:
Get-EventLog Security -newest 200
➥-computerName Server-R2,Server-DC4,Server12
➥| Where { $_.EventID -eq 1212 }
In the previous example, we used the -computerName parameter of Get-EventLog,
rather than invoking the entire command remotely. We’ll get more or less the same
results, but there are some important differences in how this version of the command
executes:
 The computers will be contacted sequentially rather than in parallel, which
means the command may take longer to execute.
 The output won’t include a PSComputerName property, which may make it
harder for us to tell which result came from which computer.
 The connection won’t be made using WinRM, but will instead use whatever
underlying protocol the .NET Framework decides to use. We don’t know what
that is, and it might be harder to get the connection through any firewalls
between us and the remote computer.
 We’re querying 200 records from each of the three computers, and only then
are we filtering through them to find the ones with EventID 1212. That means
we’re probably bringing over a lot of records we don’t want.
 We’re getting back event log objects that are fully functional.
These differences apply to any cmdlet that has a -computerName parameter. Generally
speaking, it can be more efficient and effective to use Invoke-Command rather than a
cmdlet’s -computerName parameter.
 Here’s what would have happened if we’d used the original Invoke-Command
instead:
 The computers would have been contacted in parallel, meaning the command
could complete somewhat more quickly.
 The output would have included a PSComputerName property, enabling us to
more easily distinguish the output from each computer.
 The connection would have been made through WinRM, which uses a single
predefined port that can make it easier to get through any intervening firewalls.
 Each computer would have queried the 200 records and filtered them locally.
The only data transmitted across the network would have been the result of
that filtering, meaning that only the records we cared about would have been
transmitted.
 Before transmitting, each computer would have serialized its output into XML.
Our computer would have received that XML and deserialized it back into
something that looks like objects. But they wouldn’t have been real event log
objects, and that might limit what we could do with them once they were on our
computer.
That last point is a big distinction between using a -computerName parameter and
using Invoke-Command. Let’s discuss that distinction.
13.5.2 Local versus remote processing
We’ll cite our original example again:
Invoke-Command -computerName Server-R2,Server-DC4,Server12
➥-command { Get-EventLog Security -newest 200 |
➥Where { $_.EventID -eq 1212 }}
Now, compare it to this alternative:
Invoke-Command -computerName Server-R2,Server-DC4,Server12
➥-command { Get-EventLog Security -newest 200 } |
➥Where { $_.EventID -eq 1212 }
The differences are subtle. Well, we see only one difference: we moved one of those
curly braces.
 In the second version, only Get-EventLog is being invoked remotely. All of the
results generated by Get-EventLog will be serialized and sent to our computer, where
they’ll be deserialized into objects and then piped to Where and filtered. The second
version of the command is less efficient, because a lot of unnecessary data is being
transmitted across the network, and our one computer has to filter the results from
three computers, rather than those three computers filtering their own results for us.
The second version, then, is a bad idea.
 Let’s look at two versions of another command, starting with the following:
Invoke-Command -computerName Server-R2
➥-command { Get-Process -name Notepad } |
➥Stop-Process
Now let’s look at the second version:
Invoke-Command -computerName Server-R2
➥-command { Get-Process -name Notepad |
➥Stop-Process }
Once again, the only difference between these two is the placement of a curly brace.
But in this example, the first version of the command won’t work.
 Look carefully: we’re sending Get-Process -name Notepad to the remote computer. The remote computer retrieves the specified process, serializes it into XML, and
sends it to us across the network. Our computer receives that XML, deserializes it back
into an object, and pipes it to Stop-Process. The problem is that the deserialized
XML doesn’t contain enough information for our computer to realize that the process
came from a remote machine. Instead, our computer will try to stop the Notepad process
running locally, which isn’t what we want at all.
 The moral of the story is to always complete as much of your processing on the
remote computer as possible. The only thing you should expect to do with the results
of Invoke-Command is to display them or store them as a report, or a data file, or so
forth. The second version of our command follows that advice: what’s being sent to
the remote computer is Get-Process -name Notepad | Stop-Process, so the entire
command—both getting the process and stopping it—happens on the remote computer. Because Stop-Process doesn’t normally produce any output, there won’t be
any objects to serialize and send to us, so we won’t see anything on our local console.
But the command will do what we want: stop the Notepad process on the remote computer, not on our local machine.
 Whenever we use Invoke-Command, we always look at the commands after it. If we
see commands for formatting, or for exporting data, we’re fine, because it’s OK to do
those things with the results of Invoke-Command. But if Invoke-Command is followed by
action cmdlets—ones that start, stop, set, change, or do something else—then we sit
back and try to think about what we’re doing. Ideally, we want all of those actions to
happen on the remote computer, not on our local computer.
13.5.3 Deserialized objects
Another caveat to keep in mind about remoting is that the objects that come back to
your computer aren’t fully functional. In most cases, they lack methods, because
they’re no longer “attached” to “live” software.
 For example, run this on your local computer and you’ll notice that a
Service-Controller object has numerous methods associated with it:
PS C:\> get-service | get-member
 TypeName: System.ServiceProcess.ServiceController
Name MemberType Definition
---- ---------- ----------
Name AliasProperty Name = ServiceName
RequiredServices AliasProperty RequiredServices = ServicesDep
Disposed Event System.EventHandler Disposed(S
Close Method System.Void Close()
Continue Method System.Void Continue()
CreateObjRef Method System.Runtime.Remoting.ObjRef
Dispose Method System.Void Dispose()
Equals Method bool Equals(System.Object obj)
ExecuteCommand Method System.Void ExecuteCommand(int
GetHashCode Method int GetHashCode()
GetLifetimeService Method System.Object GetLifetimeServi
GetType Method type GetType()
InitializeLifetimeService Method System.Object InitializeLifeti
Pause Method System.Void Pause()
Refresh Method System.Void Refresh()
Start Method System.Void Start(), System.Vo
Stop Method System.Void Stop()
WaitForStatus Method System.Void WaitForStatus(Syst
CanPauseAndContinue Property bool CanPauseAndContinue {get;
CanShutdown Property bool CanShutdown {get;}
CanStop Property bool CanStop {get;}
Container Property System.ComponentModel.IContain
DependentServices Property System.ServiceProcess.ServiceC
Now get some of those same objects via remoting:
PS C:\> Invoke-Command -ScriptBlock { Get-Service } -ComputerName
DONJONESE408 | Get-Member
 TypeName: Deserialized.System.ServiceProcess.ServiceController
Name MemberType Definition
---- ---------- ----------
ToString Method string ToString(), string ToString(string
format, System.I
Name NoteProperty System.String Name=AeLookupSvc
PSComputerName NoteProperty System.String PSComputerName=DONJONESE408
PSShowComputerName NoteProperty System.Boolean PSShowComputerName=True
RequiredServices NoteProperty
Deserialized.System.ServiceProcess.ServiceController[] Req
RunspaceId NoteProperty System.Guid RunspaceId=6dc9e130-f7b2-4db4-
8b0d-3863033d7df
CanPauseAndContinue Property System.Boolean {get;set;}
CanShutdown Property System.Boolean {get;set;}
CanStop Property System.Boolean {get;set;}
Container Property {get;set;}
DependentServices Property
Deserialized.System.ServiceProcess.ServiceController[] {ge
DisplayName Property System.String {get;set;}
MachineName Property System.String {get;set;}
ServiceHandle Property System.String {get;set;}
ServiceName Property System.String {get;set;}
ServicesDependedOn Property
Deserialized.System.ServiceProcess.ServiceController[] {ge
ServiceType Property System.String {get;set;}
Site Property {get;set;}
Status Property System.String {get;set;}
The methods—except the universal ToString() method common to all objects—are
gone. This is a read-only copy of the object; you can’t tell it to do things like stop,
pause, resume, and so forth. So any actions you want taken as the result of your command should be included in the script block that’s sent to the remote computer; that
way, the objects are still live and contain all of their methods.
13.6 But wait, there’s more
The previous examples have all used ad hoc remoting connections, meaning that we
specified computer names. If you’re going to be reconnecting to the same computer
(or computers) several times within a short period of time, you can create reusable,
persistent connections to use instead. We’ll cover that technique in chapter 20.
 We should also acknowledge that not every company is going to allow PowerShell
remoting to be enabled—at least, not right away. Companies with extremely restrictive
security policies may, for example, have firewalls on all client and server computers,
which would block the remoting connection. If your company is one of those, see if an
exception is in place for Remote Desktop Protocol (RDP). We find that’s a common
exception, because administrators obviously need some remote connectivity to servers. If RDP is allowed, try to make a case for PowerShell remoting. Because remoting
connections can be audited (they look like network logins, much like accessing a file
share would appear in the audit log), they’re locked down by default to only permit
Administrators to connect. It’s not that different from RDP in terms of security risks,
and it imposes much less overhead on the remote machines than RDP does.
13.7 Remote options
Read their help files, and you’ll notice that both Invoke-Command and Enter-PSSession
have a -SessionOption parameter, which accepts a <PSSessionOption> object. What’s
that all about?
 As we just explained, both of those commands initiate a new PowerShell connection, or session, when they run. They do their thing, and then close that session automatically for you. A session option is a set of options that you can specify to change the
way the session is created. The New-PSSessionOption command does the magic.
Among other things, you can use it to specify the following:
 Open, cancellation, and idle timeouts
 Elimination of the normal data stream compression or encryption
 Various proxy-related options, for when the traffic is passing through a proxy
server
 Skips of the remote machine’s SSL certificate, name, and other security features
For example, here’s how you could open a session and skip the machine name check:
PS C:\> Enter-PSSession -ComputerName DONJONESE408
➥-SessionOption (New-PSSessionOption -SkipCNCheck)
[DONJONESE408]: PS C:\Users\donjones\Documents>
Review the help for New-PSSessionOption to see what it can do for you; in chapter 20
we’ll be using a few of those options to accomplish some advanced remoting tasks.
13.8 Common points of confusion
Whenever we start using remoting in a class we’re teaching, we’ve found some common problems that will crop up over the course of the day:
 Remoting only works, by default, with the remote computer’s real computer
name. You can’t use DNS aliases or IP addresses. In chapter 23, we’ll discuss
some of the background behind this limitation and show you how to work
around it.
 Remoting is designed to be more or less automatically configuring within a
domain. If every computer involved, and your user account, all belong to the
same domain (or trusting domains), things will typically work great. If not,
you’ll need to run help about_remote_troubleshooting and dig into the
details. One area where you might have to do this is if you’re remoting across
domains. You may have to do a tiny bit of configuration in order for that to
work, and the help file describes it in detail.
 When you invoke a command, you’re asking the remote computer to launch
PowerShell, run your command, and then close PowerShell. The next command you invoke on that same remote computer will be starting from scratch—
anything that was run in the first invocation will no longer be in effect. If you
need to run a whole series of related commands, put them all into the same
invocation.
 Make absolutely certain that you’re running PowerShell as an administrator, particularly if your computer has User Account Control (UAC) enabled. If the
account you’re using doesn’t have Administrator permissions on the remote computer, use the -credential parameter of Enter-PSSession or Invoke-Command
to specify an alternative account that does have Administrator permissions.
 If you’re using a local firewall product other than the Windows Firewall,
Enable-PSRemoting won’t set up the necessary firewall exceptions. You’ll need
to do it manually. If your remoting connection will need to traverse a regular
firewall, such as one implemented on a router or proxy, it’ll also need a manually entered exception for the remoting traffic.
 Don’t forget that any settings in a Group Policy object (GPO) override anything
you configure locally. We’ve seen administrators struggle for hours to get
remoting to work, only to finally discover that a GPO was overriding everything
they did. In some cases, a well-meaning colleague may have put GPO into place
a long time ago and forgotten it was there. Don’t assume that there’s no GPO
affecting you; check and see for sure.


13.9 Lab
NOTE For this lab, you’ll need any computer running PowerShell v3. Ideally,
you’ll want to have two computers that are each members of the same Active
Directory domain, but if you have only one computer to test with, that’s fine.
It’s time to combine some of what you’ve learned about remoting with what you’ve
learned in previous chapters. See if you can accomplish the following tasks:
1 Make a one-to-one connection with a remote computer (or with “localhost” if
you only have one computer). Launch Notepad.exe. What happens?
    Enter-PSSession Server01
    [Server01] PS C:\Users\Administrator\Documents > Notepad
    The Notepad process will launch, but threre won't be any anteractive process either locally or remotely. In fact, run this way, the prompt won't return until the Notepad process ends - although an alternative command to launch is Start-Process Notepad


2 Using Invoke-Command, retrieve a list of services that aren’t started from one or
two remote computers (it’s OK to use “localhost” twice if you only have one
computer). Format the results as a wide list. (Hint: it’s OK to retrieve results and
have the formatting occur on your computer—don’t include the Formatcmdlets in the commands that are invoked remotely.)
    Invoke-Command -scriptblock {get-service | where {$_.status  -eq "stopped"}} -computer Server01,Server02 | format-wide -Column 4
    
3 Use Invoke-Command to get a list of the top ten processes for virtual memory
(VM) usage. Target one or two remote computers, if you can; if you only have
one computer, target “localhost” twice.
    Invoke-Command -scriptblock {get-process | sort VM -Descending | Select -first 10} -computername Server01,Server02

4 Create a text file that contains three computer names, with one name per line.
It’s OK to use the same computer name, or “localhost,” three times if you only
have access to one remote computer. Then use Invoke-Command to retrieve the
100 newest Application event log entries from the computer names listed in
that file.
    Invoke-Command -scriptblock {get-eventlog -LogName Application - Newest 100} -ComputerName (Get-Content computers.txt)
